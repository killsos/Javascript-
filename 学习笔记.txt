#1

ECMAScript 和 Javascript

网景 livescript 后来改为 Javascript

JS引擎:

Mozilla      SpiderMonkey

Microsoft    JScript

Google       v8

Apple        javascriptCore

JIT  实时编译

just in compilation

通过编译javascript源码为字节码来加速javascript的执行速度

标准与实现

实现是按照标准与规范的实现

javascript和JScript都可以客户端和服务器端运行 只是解释引擎

javascript服务端解释引擎是Netscape服务器Livewire
JScript与VBscript使用相同的服务端解释引擎 属于ASP语法

脚本语言: 二进制方式  脚本方式

#2
浏览器的发展
美国伊利诺斯大学  Mosaic浏览器

#3 网页中javascript
<script></script>

defer属性 用来通知浏览器 这段脚本代码不会产生任何文档内容

<script src="script.js"></script>

没有 defer 或 async，浏览器会立即加载并执行指定的脚本，
“立即”指的是在渲染该 script 标签之下的文档元素之前，
也就是说不等待后续载入的文档元素，读到就加载并执行

<script async src="script.js"></script>

有 async，
加载和渲染后续文档元素的过程将
和 script.js 的加载与执行并行进行（异步）

<script defer src="myscript.js"></script>

有 defer，加载后续文档元素的过程将和 script.js 的加载并行进行（异步）
但是 script.js 的执行要在所有元素解析完成之后
DOMContentLoaded 事件触发之前完成。

https://segmentfault.com/q/1010000000640869

async与defer组合:

1. 如果定义async 脚本是异步的

2. 如果没有async 定义defer 脚本会在文档解析DOMContentLoaded完成执行

3. 如果async defer 同时没定义 脚本会被理解下载 下载完成后立即执行

noscript
noscript 元素用来定义在脚本未被执行时的替代内容（文本）
此标签可被用于可识别 <script> 标签但无法支持其中的脚本的浏览器
仅在下列情况被渲染:
1 用户浏览器被设置为不能执行脚本

2 用户浏览器不支持script元素调用的脚本元素

默认脚本语言
通过meta指定 

#3
声明与命名变量

1 一条声明语句可以声明多个变量 用逗号隔开
00.js

2 一条声明语句可以声明多个变量 用逗号隔开
01.js
这个语句所有变量都是该语句的声明操作符控制

3 javascript区分变量大小写
02.js

变量名与标识符的命名规范
1. 首字符必须为 字母 下划线 美元符号
2. 除去首字符后面可以是 字母 数字 下划线 美元符号
3. 变量名不能是关键字

变量的数据类型

简单 原始数据类型
布尔 字符 数字 undefined null

字符串转义:
\n  换行      10
\r  回车      9
\'  单引号    27
\"  双引号    22

null 空值

数字：
八进制     前缀是0  后面数字0-7之间
十六进制   前缀是0x 后面数字0-F之间

八进制和十六进制可以是负数 但不能是小数

数字常量: Infinity  NaN

复杂数据类型:
数组

对象

undefined:
未初始化的变量 未初始化对象属性

undefined用于不同的数据类型转换结果也不同

String()    返回字符串undefined

Number()    返回NaN

Object()    返回新的对象实例

null == undefined // true

null === undefined // false

使用一个var可以同时声明多个变量的值 变量之间使用都好隔开

var a = true, b = 123;

var关键字在定义变量的时候为多个变量赋相同的值

var  a =  b  = c = 1;
// 但是有问题 b c 是全局变量
03.js


变量提升:
1. 全局变量声明提升到最顶部
2. 函数内变量声明提升函数最顶部

3. 当遇到变量名与函数名相同  函数名优先
03.js

变量分为:按值传递 按引用传递


内存规则: 堆和栈

堆和栈都是运行时内存中分配的一个数据区 因此称之为 堆区 和  栈区
但两者存储的数据类型和处理速度不同

堆 heap 用于处理复杂数据类型分配空间
例如数据 对象 它们都是在运行时动态分配内存 因此存取速度慢

栈 stack 用于存储基本数据类型和对象的引用
优势存取速度比堆快
并且栈内的数据可以共享
缺点是存在栈中的数据大小与生存期必须是确定 缺乏灵活性

栈的使用规则:
栈最重要特性是: 数据共享
04.js


堆得使用规则:
05.js

易犯的错误:
06.js

逻辑等于 与 逻辑全等
逻辑等于 首先将变量转成相同的数据类型
然后进行对比

逻辑全等 首先比较数据类型 然后看是否引用的同一个数据
07.js


数据类型转换:
显式转换  隐式转换

命名方法:
1. 帕斯卡命名
所有单词的第一个字母大写 其他字母小写

2. 驼峰命名
第一个单词外 其他单词第一个字母大写 其他字母小写

3. 匈利亚命名
一个字母前缀 用于只是作用域 类型的信息
然后是变量的功能描述信息
功能描述信息是首字母大写的一个或多个单词的组合
该单词往往要指明变量的用途


重构:
一个文件超过500行
一个函数超过30行

严格模式:
全局严格  函数严格
"use strict"

1. 变量必须先声明后使用
2. 删除全局变量 全局函数 或者 删除函数参数 会报错
3. 不能重复定义相同属性
4. arguments属性是只读
5. arguments.caller arguments.callee 不能用
arguments.callee  当前被调用的函数
arguments.caller  谁调用了当前执行的函数
08.js

6. 不能eval
7. 不能用with
with会引入一个上下文环境

8. 不能八进制

运算符:

1 算术运算符

+ - * /  加减乘除

2 累加累减

++ -- 分前后两种

3 赋值运算符
=
+=
-=
*=
/=
%=
&= 按位与
|= 按位或
<<=
=>>
=>>>
^=

4 字符串运算符
+ 连字符

多个数字 加法
单个数字与其他类型的数据使用+ 首先都转为字符串 然后连接
多个个数字与其他类型的数据使用+ 从左向右执行

5 比较运算符

<
>
<=
=>
==
===
!=
!==

6 逻辑运算符

&&
||
！
&&=
||=

7 特殊值比较

NaN == NaN //false
NaN === NaN //false

null == undefined //true
null != undefined //true
null >= undefined //true
null <= undefined //true


null === undefined // false 它们不是对象
null == undefined //true

09.js

逻辑等于 与 逻辑全等
逻辑等于 首先将变量转成相同的数据类型
然后进行对比

逻辑全等 首先比较数据类型 然后看是否引用的同一个数据

7 位运算符

&
|
~
^
<<
>>
>>> 无符号右移

8 其他运算符

[] 下标运算符

,  逗号运算符 返回最右一个值

(express1)？(express2)：(express3) 三元运算符

in 

instanceof

new 

{}  定义一个块

() 分组运算符

typeof
返回值：
undefined --- undefined
null --- object
true/false --- boolean
Number --- Number
Number --- Number
object(没有实现[[Call]]属性的对象) --- object
object(实现[[Call]]属性的对象) --- function
symbol() --- symbol

object(host) --- Object.prototype.toString.call(obj)  === '[object Array]'

Array Set  WeakSet Map WeakMap
10.js

void 计算机表达式 然后放弃其值 返回undefined


#4 流程控制

1. 语句和语句块
语句是由一个或多个表达式、关键字或者运算符组成

语句块是由{}括起来

if(){}

if(){}
else{}

if(){

}else if(){

} else {

}

switch (express){
    case value: 
    break;

    default:
    break;
}


do {

} while()

while(){

}

for(expr1; expr2; expr3){
    break;
    continue;
}

遍历属性名
for(var in object){
    break;
    continue;
}

自定义原型属性可以枚举

遍历属性值
for each(var in object){

}

with语句 引用某个特定对象的方法和属性
whit(object){
    statement(s)
}

#5 全局函数

1. eval函数
计算表达

2. 转义函数
escape()
将参数转换为字符串
并以URL编码格式进行编码
在这种格式中 所有空格 标点 重音符号
以及其他非ASCII字符都用%xx十六进制序列
编码代替 
例如:
空格      %20
叹号！    %21
双引号"   %22
井号#     %23
$         %24
%         %25
&         26
'         27

escape() 
unescape()

用escape/unescape处理非ASCII字符时会出错
它们不能用来堆unicode进行编解码
推荐用encodeURI/decodeURI


encodeURI函数将文本字符串编码为一个有效的统一资源标识符URL
encodeURI(URLString)
URLString---一个编码的URI的字符串

encodeURI对以下字符不编码:
保留字符: 
反向转义字符:
#号
---反向decodeURI()

encodeURI函数单靠自身不能形成HTTP GET请求或POST请求
因为 & + = 不会编码
所以要使用encodeURIComponent()
decodeURIComponent()

parseFloat()  非浮点数 返回值NaN

parseInt()   非整数 返回值NaN

以0开头为8进制

以0x开头为16进制

#6 函数

函数提升
12.js

匿名函数

函数语句与函数表达式的区别:
1. 函数定义

关键字 function

函数返回值 用return

2. 函数调用

3. 函数中定义参数的初始值

通过arguments对象来完成

4. 嵌套函数的定义和调用
13.js

5. 条件分支定义函数的问题
14.js

6. 匿名函数
没有命名的函数
15.js

7. 函数表达式与函数语句的区别

* 函数语句会预解析  函数表达式不会预解析

* 函数表达式可以作为另一个函数或方法的参数

* 函数表达式可以通过设为null 或 delete方式进行垃圾回收

* 函数语句不可以通过设为null 或 delete方式进行垃圾回收
16.js

8. 匿名自执行函数

形式1:

(function(){
    
})()

形式2:
(function(a,b,...){
    
})(arg1,arg2,...)

由于函数是一个封闭的作用域范围
并且可以嵌套函数
所以可以使用这种匿名函数自执行函数
来实现封装自己的所有函数和变量
从而避免来自多个开发者的多个函数
相互冲突
并且由于它们位于同一个函数中
所有可以相互引用

由于外部无法引用函数内部的变量
因此在执行完后很快就会被释放
关键是这种机制不会污染全局对象
同时相当于定义一个命名空间
来自不同开发镇的功能位于
自己的命名空间内

哪如何访问匿名自执行函数里面的函数和对象呢？
同时是为函数定义一个参数
该参数是一个对象
在里面的函数或变量前加上一个对该对象的引用
这样该函数或变量就成为该对象的方法或属性
17.js

9. 使用Function类定义函数

var functionName = new Function([arg1, arg2,...], functionBody)

arg 是参数 是字符串

functionBody 是函数体
18.js

10. 变量 作用范围 和 生命周期

变量作用范围: 是指一个区域
只有该区域内变量才是已知
并且才可以被引用

javascript变量也有自己的作用范围
scope---也称为作用域
以及生命周期

在Javascript的程序执行时
系统会在内存中保留一块全局变量的区域
可以直接使用变量名访问变量值

变量的作用域由声明的位置决定
声明一个变量同时指出一个变量的作用范围
在一个确定的范围中 变量名应该是唯一的

变量作用域分为 函数级变量 和 全局级变量

如果不用var声明变量 就是会变成全局变量
同时在严格模式下会报错

11. 形参和实参

形参 形式参数
是定义函数名和函数体时使用的参数
目的是用来接收调用该函数时传进的参数

实参 实际参数
是调用时传递给函数的参数

在函数调用时 形参和实参是不同的变量
它们在内存中位置不同
形参将实参内容复制一份
在该函数运行结束的时候
形参被释放
而实参内容不变
---
这是上面只对基本数据类型是对
而对对象是错误的 刚好相反
19.js

总的来说
形参只是为了完成某一目的而定义在函数里的
当进行函数调用时
会临时给形参分配一个存储空间
当该函数调用结束时候
也就释放了这个存储空间

如果形参和函数内部变量名相同的情况
20.js

12. arguments对象
arguments对象可以直接在函数内使用
是Function类的一个属性
用于获取传递给函数的参数
但是如果形参名也是arguments
这就意味着形参arguments覆盖了语言本身提供的arguments对象
21.js


13. 闭包函数
闭包closure是一个函数
通常称为闭包函数或绑定函数
该函数运行在一个特定环境中
该环境定义了一些本地变量
当该函数被调用时
仍可以使用这些本地变量

什么是闭包函数
当一个函数在不位于它所处环境
(变量作用范围)中调用时候
仍能够使用本地变量
这就是闭包函数的显著特征

1) 作为值从函数返回的函数时闭包函数
22.js

2) 利用变量作用范围也可以形成闭包函数
作为参数传递给函数的函数或作为值从函数返回的
函数都是闭包函数
23.js

闭包函数核心是:
函数所能的变量取决于声明函数的位置
不取决于调用位置

核心:是函数无论在哪里调用
仍可以访问它所处环境的变量
而这个变量在函数被调用的环境中是被其他程序
访问不到的

闭包常用环境
在执行函数之前就向函数传递参数

function outer(param){
    return (function(){
        console.log(param);
    })
}

var funcRef = outer('123');

setTimeout(funcRef, 1000)

易犯的错误:
24.js

#7 面向对象OOP

1. 面向对象编程 oop object oriented programming

抽象是一种归纳或总结 对象是现实世界物体特征的实体

一切皆是对象

类是对象的抽象

面向对象编程的实质性内涵是将所有的业务逻辑单元
都视为一个对象
并且 类也不是唯一的用来完成面向对象编程的方法
例如 javascript使用构造器和原型来完成面向对象开发

程序设计:
对象 = 数据 + 作用于这些数据上的操作(算法)

面向对象程序设计:
可重用性
易于维护性

面向对象基本特征:
封装性  encapsulation
继承性  inheritance
多态性  ploymorphic  根据参数不同

重载和覆载是多态的实现方式

面向对象和结构化程序设计区别

结构化程序设计
采用了模块分级与功能抽象
和自顶向下 分而治之的方法
这是一种面向过程的设计思想

面向过程编程的任务是将一个程序分割成
变量的集合  数据结构  子程序 三部分

面向对象这是一个程序分割成对象

面向对象编程                     面向过程编程
Methods 方法                    Functions 函数
Objects 对象                    Modules   模块
Message 信息                    Arguments 参数
Attribute 属性                  Variable  变量

类 方法 属性  继承

通过 new 关键字

类的定义
类声明  类体

类名首字母大写 按照帕斯卡命名法的规范为类命名

构造器方法是没有返回值 当创建该类实例时候 必需调用该类的构造方法

所有的构造器都是类
但是并非所有的类都是构造器

内建的类是使用构造器创建的类
但是宿主对象 window navigator 可能不是

对于实例使用constructor属性
便可以获取实例的构造器方法
25.js

静态类无需实例化就可以直接调用类的方法和属性

访问对象属性
.符号  
['属性名']中括号

调用对象方法
.符号  
['方法名']中括号

调用静态方法和属性
静态就是无需实例 直接调用
26.js

使用this关键字定义方法和属性

使用prototype定义方法和属性
每个类都有prototype属性
该属性是一个静态属性
因此无需实例化
默认是一个空对象
27.js

关于prototype和__proto__的区别
每个构造器方法都有一个prototype属性
该属性是在定义构造器方法时自动创建的
prototype属性代表用该函数创建的类的默认属性值
如果将方法分配给类的prototype属性
则该类的任何新创建的实例都可以使用这些方法

类的每个新实例也都有一个__proto__属性
用于引用创建它的构造器方法的prototype属性
可以使用prototype和__proto__属性
扩展类 这样可以以面向对象的方式重新使用代码
28.js

IE不支持__proto__

使用return语句定义方法和属性
可以使用return语句定义方法和属性
只需为构造方法定义返回值
在return语句中声明一个对象
该对象可以利用对象命名定义属性和方法
29.js

